---
title:  PicoCTF 2018 - Binary Exploits
description: Writeups for PicoCTF 2018 Binary Exploitation Challenges.
image:
  path: /img/reference/pico-ctf-2018-00000.png
  width: 1024
  height: 512
  thumb: /img/reference/pico-ctf-2018-00000.thumb.png
  alt: Linux Terminal
---

# PicoCTF 2018 - Binary Exploitation Challenges

We've solved every single last PicoCTF 2018 Binary Exploitation challenge. Read our writeups to up your hacker game and learn what you've been missing. For more information on what PicoCTF is, read our introductory [Blog Post]({% post_url /featured/2020-08-11-Hacking-the-pandemic-away %}).

***NOTE*: These writeups are a work-in-progress. Keep coming back as content is updated regularly.**

## Getting Started

**Required tools**: ssh client

Strictly speaking, you should be able to do almost all of the challenges without any additional tools than what is available on the ssh server.

However, I would recommend downloading the problems and working locally. For Ubuntu systems, you'll want to do the following:

```
sudo dpkg --add-architecture i386
sudo apt-get update
sudo apt-get install -y libc6-dbg lib32stdc++6 libc6-dbg:i386 libstdc++6:i386
```
{:.contains-term}

Which should allow you to execute 32-bit binaries on a 64-bit Ubuntu installation.

In addition, you'll likely want to install packages for **binutils**, **python3**, **pwntools**, **netcat**, and **nasm**.

### Windows Users

Fear not, it is relatively easy to work on these problems from your windows machine (*I did*). At the end of the day, these are linux binaries, so you will still need access to a linux instance to run them. Both Docker and WSL2 will allow you to have complete linux instances running in a virtual machine. WSL1 is also an option, and will get you surprising far, but the caveat is that 32-bit binaries are explicitly not supported by WSL1, so you will have to run those challenges on the shell server.

## List of Challenges

### 1. [buffer overflow 0]({% link _reference/Hacking-101/PicoCTF-2018-Binary-Exploits/buffer-overflow-0.md %}) (*150 Points*)

> 
```
$ ./vuln abcd
Thanks! Received: abcd
```
> The trick with this challenge is to make the program segfault (in the right way). The binary already registers a segfault handler that, if successfully executed, will print out the flag. All you have to do? **Make it crash**!  
> [> Read More]({% link _reference/Hacking-101/PicoCTF-2018-Binary-Exploits/buffer-overflow-0.md %})
{:.contains-term}

### 2. [buffer overflow 1]({% link _reference/Hacking-101/PicoCTF-2018-Binary-Exploits/buffer-overflow-1.md %}) (*200 Points*)

>
```
$ ./vuln
Please enter your string:
abcd
Okay, time to return... Fingers Crossed... Jumping to 0x80486b3
```
> The training-wheels come off, and you have to use the buffer-overflow vulnerability to execute a specific bit of code at an exact location in memory. The question is, can *you* get it to work?  
> [> Read More]({% link _reference/Hacking-101/PicoCTF-2018-Binary-Exploits/buffer-overflow-1.md %})
{:.contains-term}

### 3. [leak-me]({% link _reference/Hacking-101/PicoCTF-2018-Binary-Exploits/leak-me.md %}) (*200 Points*)

>
```
$ ./auth
What is your name?
abcd
Hello abcd,
Please Enter the Password.
password
Incorrect Password!
```
> It's still a buffer overflow, but it won't crash and it won't execute code. How will *you* trick it into revealing its secrets?  
> [> Read More]({% link _reference/Hacking-101/PicoCTF-2018-Binary-Exploits/leak-me.md %})
{:.contains-term}

### 4. [shellcode]({% link _reference/Hacking-101/PicoCTF-2018-Binary-Exploits/shellcode.md %}) (*200 Points*)

>
```
$ ./vuln
Enter a string!
abcd
abcd
Thanks! Executing now...
Segmentation fault
```
> In which we hand-craft some artisanal x86 shellcode.  
> [> Read More]({% link _reference/Hacking-101/PicoCTF-2018-Binary-Exploits/shellcode.md %})
{:.contains-term}

### 5. buffer overflow 2 (*250 Points*)

>
```
$ ./vuln
Please enter your string:
abcd
abcd
```
> *COMING SOON*  
{:.contains-term}

### 6. got-2-learn-libc (*250 Points*)

>
```
$
```
> *COMING SOON*  
{:.contains-term}

### 7. echooo (*300 Points*)

>
```
$
```
> *COMING SOON*  
{:.contains-term}

### 8. authenticate (*350 Points*)

>
```
$
```
> *COMING SOON*  
{:.contains-term}

### 9. got-shell? (*350 Points*)

>
```
$
```
> *COMING SOON*  
{:.contains-term}

### 10. rop chain (*350 Points*)

>
```
$
```
> *COMING SOON*  
{:.contains-term}

### 11. buffer overflow 3 (*450 Points*)

>
```
$
```
> *COMING SOON*  
{:.contains-term}

### 12. echo back (*500 Points*)

>
```
$
```
> *COMING SOON*  
{:.contains-term}

### 13. are you root? (*550 Points*)
>
```
$
```
> *COMING SOON*  
{:.contains-term}

### 14. gps (*550 Points*)

>
```
$
```
> *COMING SOON*  
{:.contains-term}

### 15. can-you-gets-me (*650 Points*)

>
```
$
```
> *COMING SOON*  
{:.contains-term}

### 16. freecalc (*750 Points*)

>
```
$
```
> *COMING SOON*  
{:.contains-term}

### 17. sword (*800 Points*)

>
```
$
```
> *COMING SOON*  
{:.contains-term}

### 18. Contacts (*850 Points*)

>
```
$
```
> *COMING SOON*  
{:.contains-term}

### 19. Cake (*900 Points*)

>
```
$
```
> *COMING SOON*  
{:.contains-term}

### 20. no args (*1000 Points*)

>
```
$
```
> *COMING SOON*  
{:.contains-term}


