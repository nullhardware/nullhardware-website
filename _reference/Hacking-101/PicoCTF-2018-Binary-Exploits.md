---
title:  PicoCTF 2018 - Binary Exploits
description: Writeups for PicoCTF 2018 Binary Exploitation Challenges.
image:
  path: /img/reference/pico-ctf-2018-00000.png
  width: 1024
  height: 512
  thumb: /img/reference/pico-ctf-2018-00000.thumb.png
  alt: Linux Terminal
---

# PicoCTF 2018 - Binary Exploitation Challenges

We've solved every single last PicoCTF 2018 Binary Exploitation challenge. Read our writeups to up your hacker game and learn what you've been missing. For more information on what PicoCTF is, read our introductory [Blog Post]({% post_url /featured/2020-08-11-Hacking-the-pandemic-away %}).

***NOTE*: These writeups are a work-in-progress. Keep coming back as content is updated regularly.**

## Getting Started

**Required tools**: ssh client

Strictly speaking, you should be able to do almost all of the challenges without any additional tools than what is available on the ssh server.

However, I would recommend downloading the problems and working locally. For Ubuntu systems, you'll want to do the following:

```
sudo dpkg --add-architecture i386
sudo apt-get update
sudo apt-get install -y libc6-dbg lib32stdc++6 libc6-dbg:i386 libstdc++6:i386
```
{:.contains-term}

Which should allow you to execute 32-bit binaries on a 64-bit Ubuntu installation.

In addition, you'll likely want to install packages for **binutils**, **python3**, **pwntools**, **netcat**, and **nasm**.

### Windows Users

Fear not, it is relatively easy to work on these problems from your windows machine (*I did*). At the end of the day, these are linux binaries, so you will still need access to a linux instance to run them. Both Docker and WSL2 will allow you to have complete linux instances running in a virtual machine. WSL1 is also an option, and will get you surprising far, but the caveat is that 32-bit binaries are explicitly not supported by WSL1, so you will have to run those challenges on the shell server.

## List of Challenges

### 1. [buffer overflow 0]({% link _reference/Hacking-101/PicoCTF-2018-Binary-Exploits/buffer-overflow-0.md %}) (*150 Points*)

> 
```
$ ./vuln abcd
Thanks! Received: abcd
```
> The trick with this challenge is to make the program segfault (in the right way). The binary already registers a segfault handler that, if successfully executed, will print out the flag. All you have to do? **Make it crash**!  
> [> Read More]({% link _reference/Hacking-101/PicoCTF-2018-Binary-Exploits/buffer-overflow-0.md %})
{:.contains-term}

### 2. [buffer overflow 1]({% link _reference/Hacking-101/PicoCTF-2018-Binary-Exploits/buffer-overflow-1.md %}) (*200 Points*)

>
```
$ ./vuln
Please enter your string:
abcd
Okay, time to return... Fingers Crossed... Jumping to 0x80486b3
```
> The training-wheels come off, and you have to use the buffer-overflow vulnerability to execute a specific bit of code at an exact location in memory. The question is, can *you* get it to work?  
> [> Read More]({% link _reference/Hacking-101/PicoCTF-2018-Binary-Exploits/buffer-overflow-1.md %})
{:.contains-term}

### 3. [leak-me]({% link _reference/Hacking-101/PicoCTF-2018-Binary-Exploits/leak-me.md %}) (*200 Points*)

>
```
$ ./auth
What is your name?
abcd
Hello abcd,
Please Enter the Password.
password
Incorrect Password!
```
> It's still a buffer overflow, but it won't crash and it won't execute code. How will *you* trick it into revealing its secrets?  
> [> Read More]({% link _reference/Hacking-101/PicoCTF-2018-Binary-Exploits/leak-me.md %})
{:.contains-term}

### 4. [shellcode]({% link _reference/Hacking-101/PicoCTF-2018-Binary-Exploits/shellcode.md %}) (*200 Points*)

>
```
$ ./vuln
Enter a string!
abcd
abcd
Thanks! Executing now...
Segmentation fault
```
> In which we hand-craft some artisanal x86 shellcode.  
> [> Read More]({% link _reference/Hacking-101/PicoCTF-2018-Binary-Exploits/shellcode.md %})
{:.contains-term}

### 5. [buffer overflow 2]({% link _reference/Hacking-101/PicoCTF-2018-Binary-Exploits/buffer-overflow-2.md %}) (*250 Points*)

>
```
$ ./vuln
Please enter your string:
abcd
abcd
```
> Now that you've got a handle on buffer-overflows, can *you* figure out how to use your control of the stack to pass arguments into a function?  
> [> Read More]({% link _reference/Hacking-101/PicoCTF-2018-Binary-Exploits/buffer-overflow-2.md %})
{:.contains-term}

### 6. [got-2-learn-libc]({% link _reference/Hacking-101/PicoCTF-2018-Binary-Exploits/got-2-learn-libc.md %}) (*250 Points*)

>
```
$ ./vuln
Here are some useful addresses:  
puts: 0xf7660150
fflush 0xf765e340
read: 0xf76d5440
write: 0xf76d54b0
useful_string: 0x56624030
Enter a string:
abcd
abcd
Thanks! Exiting now...
```
> Time to put all your training to work - there are no more easy `win()`s, but at least there's PIE.  
> [> Read More]({% link _reference/Hacking-101/PicoCTF-2018-Binary-Exploits/got-2-learn-libc.md %})
{:.contains-term}

### 7. [echooo]({% link _reference/Hacking-101/PicoCTF-2018-Binary-Exploits/echooo.md %}) (*300 Points*)

>
```
$ nc 2018shell.picoctf.com 34802
Time to learn about Format Strings!
We will evaluate any format string you give us with printf().
See if you can get the flag!
> abcd
abcd
```
> The trick to this one is all in **formatting** your query correctly.  
> [> Read More]({% link _reference/Hacking-101/PicoCTF-2018-Binary-Exploits/echooo.md %})
{:.contains-term}

### 8. [authenticate]({% link _reference/Hacking-101/PicoCTF-2018-Binary-Exploits/authenticate.md %}) (*350 Points*)

>
```
$ nc 2018shell.picoctf.com 52398
Would you like to read the flag? (yes/no)
yes
Sorry, you are not *authenticated*!
```
> Did you think `printf` was just for printing values? Naw, it can do more than that.  
> [> Read More]({% link _reference/Hacking-101/PicoCTF-2018-Binary-Exploits/authenticate.md %})
{:.contains-term}

### 9. got-shell? (*350 Points*)

>
```
$ nc 2018shell.picoctf.com 3582
I'll let you write one 4 byte value to memory. Where would you like to write this 4 byte value?
abcd
Okay, now what value would you like to write to 0xabcd
0
Okay, writing 0x0 to 0xabcd
timeout: the monitored command dumped core
```
> *COMING SOON*  
{:.contains-term}

### 10. rop chain (*350 Points*)

>
```
$
```
> *COMING SOON*  
{:.contains-term}

### 11. buffer overflow 3 (*450 Points*)

>
```
$
```
> *COMING SOON*  
{:.contains-term}

### 12. echo back (*500 Points*)

>
```
$
```
> *COMING SOON*  
{:.contains-term}

### 13. are you root? (*550 Points*)
>
```
$
```
> *COMING SOON*  
{:.contains-term}

### 14. gps (*550 Points*)

>
```
$
```
> *COMING SOON*  
{:.contains-term}

### 15. can-you-gets-me (*650 Points*)

>
```
$
```
> *COMING SOON*  
{:.contains-term}

### 16. freecalc (*750 Points*)

>
```
$
```
> *COMING SOON*  
{:.contains-term}

### 17. sword (*800 Points*)

>
```
$
```
> *COMING SOON*  
{:.contains-term}

### 18. Contacts (*850 Points*)

>
```
$
```
> *COMING SOON*  
{:.contains-term}

### 19. Cake (*900 Points*)

>
```
$
```
> *COMING SOON*  
{:.contains-term}

### 20. no args (*1000 Points*)

>
```
$
```
> *COMING SOON*  
{:.contains-term}


